<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Math Generator Tests</title>
<style>
  body { font-family: monospace; margin: 20px; background: #1a1a2e; color: #e0e0e0; }
  #summary { font-size: 1.3em; padding: 10px; margin-bottom: 16px; border-radius: 4px; }
  .pass { color: #4caf50; }
  .fail { color: #f44336; }
  .suite { margin: 16px 0; border: 1px solid #333; border-radius: 4px; padding: 10px; }
  .suite h2 { margin: 0 0 8px; font-size: 1.1em; }
  .test { padding: 2px 0; }
  .test.fail { background: #3a1a1a; padding: 4px 8px; margin: 2px 0; border-radius: 2px; }
  .detail { color: #ff8a80; font-size: 0.9em; margin-left: 24px; }
</style>
</head>
<body>
<h1>Math Generator — Tests</h1>
<div id="summary"></div>
<div id="results"></div>

<script src="js/problems.js"></script>
<script>
(function() {
  var passed = 0, failed = 0;
  var resultsDiv = document.getElementById('results');
  var suiteDiv = null;

  function suite(name) {
    suiteDiv = document.createElement('div');
    suiteDiv.className = 'suite';
    suiteDiv.innerHTML = '<h2>' + name + '</h2>';
    resultsDiv.appendChild(suiteDiv);
  }

  function assert(condition, name, detail) {
    var el = document.createElement('div');
    el.className = 'test';
    if (condition) {
      passed++;
      el.classList.add('pass');
      el.textContent = '\u2713 ' + name;
    } else {
      failed++;
      el.classList.add('fail');
      el.textContent = '\u2717 ' + name;
      if (detail) {
        var d = document.createElement('div');
        d.className = 'detail';
        d.textContent = detail;
        el.appendChild(d);
      }
    }
    suiteDiv.appendChild(el);
  }

  // ---------- Suite 1: Generation invariants ----------
  suite('Suite 1 — Generation invariants (N=500)');

  var N = 500;
  var tasks = [];
  var typeSeen = {};
  for (var i = 0; i < N; i++) {
    tasks.push(MathProblems.generateTask());
  }
  tasks.forEach(function(t) { typeSeen[t.type] = true; });

  var allTypes = ['add','sub','mul','div','dec_add','dec_sub','dec_mul','dec_div','frac_add','frac_sub'];
  var allSeen = allTypes.every(function(tp) { return typeSeen[tp]; });
  assert(allSeen, 'All 10 types appear over 500 generations',
    'Missing: ' + allTypes.filter(function(tp) { return !typeSeen[tp]; }).join(', '));

  var allFields = tasks.every(function(t) {
    return t.hasOwnProperty('display') && t.hasOwnProperty('hint') &&
           t.hasOwnProperty('type') && t.hasOwnProperty('answer') &&
           t.hasOwnProperty('isFraction');
  });
  assert(allFields, 'Every task has display, hint, type, answer, isFraction');

  var allEndEqual = tasks.every(function(t) { return /=\s*$/.test(t.display); });
  assert(allEndEqual, 'display always ends with =');

  var hintCorrect = tasks.every(function(t) {
    if (t.type === 'frac_add' || t.type === 'frac_sub') return t.hint !== '';
    return t.hint === '';
  });
  assert(hintCorrect, 'hint non-empty only for frac_add/frac_sub');

  var isFracCorrect = tasks.every(function(t) {
    if (t.type === 'frac_add' || t.type === 'frac_sub') return t.isFraction === true;
    return t.isFraction === false;
  });
  assert(isFracCorrect, 'isFraction true only for frac_add/frac_sub');

  var intTypes = ['add','sub','mul','div'];
  var intAnswersOk = tasks.filter(function(t) { return intTypes.indexOf(t.type) >= 0; })
    .every(function(t) { return Number.isInteger(t.answer); });
  assert(intAnswersOk, 'Integer ops produce integer answers');

  var divExact = tasks.filter(function(t) { return t.type === 'div'; })
    .every(function(t) { return Number.isInteger(t.answer); });
  assert(divExact, 'div: answer is always a whole number');

  var subPositive = tasks.filter(function(t) { return t.type === 'sub'; })
    .every(function(t) { return t.answer >= 1; });
  assert(subPositive, 'sub: result always >= 1');

  var fracSubNonNeg = tasks.filter(function(t) { return t.type === 'frac_sub'; })
    .every(function(t) { return t.answer.num >= 0; });
  assert(fracSubNonNeg, 'frac_sub: numerator >= 0');

  var noNaN = tasks.every(function(t) {
    if (t.isFraction) return !isNaN(t.answer.num) && !isNaN(t.answer.den);
    return !isNaN(t.answer) && isFinite(t.answer);
  });
  assert(noNaN, 'Answers never NaN / Infinity');

  var fracDenPos = tasks.filter(function(t) { return t.isFraction; })
    .every(function(t) { return t.answer.den > 0; });
  assert(fracDenPos, 'Fraction denominators always > 0');

  // ---------- Suite 2: Answer checking ----------
  suite('Suite 2 — Answer checking');

  // Integer
  assert(MathProblems.checkAnswer(42, false, '42'), 'Correct integer accepted');
  assert(!MathProblems.checkAnswer(42, false, '43'), 'Wrong integer rejected');
  assert(!MathProblems.checkAnswer(42, false, ''), 'Empty string rejected');
  assert(!MathProblems.checkAnswer(42, false, '   '), 'Whitespace-only rejected');

  // Decimal / locale
  assert(MathProblems.checkAnswer(3.14, false, '3,14'), 'Comma as decimal separator accepted');
  assert(MathProblems.checkAnswer(3.14, false, '3.14'), 'Dot as decimal separator accepted');
  assert(MathProblems.checkAnswer(5.55, false, '5.554'), 'Within tolerance (0.004 off) accepted');
  assert(!MathProblems.checkAnswer(5.55, false, '5.556'), 'Outside tolerance (0.006 off) rejected');
  assert(!MathProblems.checkAnswer(42, false, 'abc'), 'Non-numeric text rejected');

  // Fractions
  assert(MathProblems.checkAnswer({num:3,den:4}, true, '3/4'), 'Fraction exact match accepted');
  assert(MathProblems.checkAnswer({num:3,den:4}, true, '6/8'), 'Fraction equivalent (unreduced) accepted');
  assert(!MathProblems.checkAnswer({num:3,den:4}, true, '2/4'), 'Wrong fraction rejected');
  assert(!MathProblems.checkAnswer({num:3,den:4}, true, '3/0'), 'Fraction zero denominator rejected');
  assert(!MathProblems.checkAnswer({num:3,den:4}, true, '0.75'), 'Decimal input for fraction rejected');

  // ---------- Suite 3: formatAnswer ----------
  suite('Suite 3 — formatAnswer');

  assert(MathProblems.formatAnswer(42, false) === '42', 'Integer formats as plain string');
  assert(MathProblems.formatAnswer(3.14, false) === '3.14', 'Decimal formats as plain string');
  assert(MathProblems.formatAnswer({num:6,den:4}, true) === '3/2', 'Fraction reduces to lowest terms (6/4 -> 3/2)');
  assert(MathProblems.formatAnswer({num:3,den:7}, true) === '3/7', 'Already-reduced fraction unchanged');

  // ---------- Suite 4: Mathematical correctness (parse & verify) ----------
  suite('Suite 4 — Mathematical correctness (parse & verify, N=100 each)');

  function parseAndVerify(type, count) {
    var mismatches = [];
    for (var i = 0; i < count; i++) {
      var t;
      do { t = MathProblems.generateTask(); } while (t.type !== type);
      var d = t.display;
      var expected;

      if (type === 'add') {
        var m = d.match(/^(\d+)\s*\+\s*(\d+)\s*=$/);
        expected = parseInt(m[1]) + parseInt(m[2]);
      } else if (type === 'sub') {
        var m = d.match(/^(\d+)\s*\u2212\s*(\d+)\s*=$/);
        expected = parseInt(m[1]) - parseInt(m[2]);
      } else if (type === 'mul') {
        var m = d.match(/^(\d+)\s*\u00d7\s*(\d+)\s*=$/);
        expected = parseInt(m[1]) * parseInt(m[2]);
      } else if (type === 'div') {
        var m = d.match(/^(\d+)\s*\u00f7\s*(\d+)\s*=$/);
        expected = parseInt(m[1]) / parseInt(m[2]);
      } else if (type === 'dec_add') {
        var m = d.match(/^([\d.]+)\s*\+\s*([\d.]+)\s*=$/);
        expected = parseFloat((parseFloat(m[1]) + parseFloat(m[2])).toFixed(2));
      } else if (type === 'dec_sub') {
        var m = d.match(/^([\d.]+)\s*\u2212\s*([\d.]+)\s*=$/);
        expected = parseFloat((parseFloat(m[1]) - parseFloat(m[2])).toFixed(2));
      } else if (type === 'dec_mul') {
        var m = d.match(/^([\d.]+)\s*\u00d7\s*([\d.]+)\s*=$/);
        expected = parseFloat((parseFloat(m[1]) * parseFloat(m[2])).toFixed(2));
      } else if (type === 'dec_div') {
        var m = d.match(/^([\d.]+)\s*\u00f7\s*([\d.]+)\s*=$/);
        expected = parseFloat((parseFloat(m[1]) / parseFloat(m[2])).toFixed(2));
      } else if (type === 'frac_add') {
        var m = d.match(/^(\d+)\/(\d+)\s*\+\s*(\d+)\/(\d+)\s*=$/);
        var eNum = parseInt(m[1]) * parseInt(m[4]) + parseInt(m[3]) * parseInt(m[2]);
        var eDen = parseInt(m[2]) * parseInt(m[4]);
        expected = {num: eNum, den: eDen};
      } else if (type === 'frac_sub') {
        var m = d.match(/^(\d+)\/(\d+)\s*\u2212\s*(\d+)\/(\d+)\s*=$/);
        var eNum = parseInt(m[1]) * parseInt(m[4]) - parseInt(m[3]) * parseInt(m[2]);
        var eDen = parseInt(m[2]) * parseInt(m[4]);
        expected = {num: eNum, den: eDen};
      }

      if (t.isFraction) {
        if (expected.num * t.answer.den !== expected.den * t.answer.num) {
          mismatches.push(d + ' got ' + t.answer.num + '/' + t.answer.den +
            ' expected ' + expected.num + '/' + expected.den);
        }
      } else {
        if (Math.abs(expected - t.answer) > 0.001) {
          mismatches.push(d + ' got ' + t.answer + ' expected ' + expected);
        }
      }
    }
    return mismatches;
  }

  allTypes.forEach(function(tp) {
    var mm = parseAndVerify(tp, 100);
    assert(mm.length === 0, tp + ': display matches stored answer (100 runs)',
      mm.length > 0 ? mm.slice(0, 3).join('; ') : '');
  });

  // ---------- Suite 5: Student-safety checks ----------
  suite('Suite 5 — Student-safety checks');

  // Generate a batch for safety checks
  var safetyN = 300;
  var safetyTasks = [];
  for (var i = 0; i < safetyN; i++) safetyTasks.push(MathProblems.generateTask());

  var noNegSub = safetyTasks.filter(function(t) { return t.type === 'sub'; })
    .every(function(t) { return t.answer >= 0; });
  assert(noNegSub, 'No negative answers in sub type');

  var divExact2 = safetyTasks.filter(function(t) { return t.type === 'div'; })
    .every(function(t) {
      var m = t.display.match(/^(\d+)\s*\u00f7\s*(\d+)\s*=$/);
      return t.answer * parseInt(m[2]) === parseInt(m[1]);
    });
  assert(divExact2, 'Division always exact (answer * divisor = dividend)');

  var decTypes = ['dec_add','dec_sub','dec_mul','dec_div'];
  var decPlacesOk = safetyTasks.filter(function(t) { return decTypes.indexOf(t.type) >= 0; })
    .every(function(t) {
      var s = String(t.answer);
      var parts = s.split('.');
      return parts.length === 1 || parts[1].length <= 2;
    });
  assert(decPlacesOk, 'Decimal answers have <= 2 decimal places');

  var fracSubNonNeg2 = safetyTasks.filter(function(t) { return t.type === 'frac_sub'; })
    .every(function(t) { return t.answer.num >= 0; });
  assert(fracSubNonNeg2, 'Fraction subtraction never negative');

  // Tolerance not too loose: off-by-1 integer should fail
  assert(!MathProblems.checkAnswer(100, false, '101'), 'Tolerance not so loose that off-by-1 integers pass');

  // Tolerance not too tight: valid rounding within 0.005 passes
  assert(MathProblems.checkAnswer(3.33, false, '3.334'), 'Tolerance not so tight that valid rounding fails');

  // ---------- Summary ----------
  var summaryDiv = document.getElementById('summary');
  var total = passed + failed;
  summaryDiv.innerHTML = '<span class="' + (failed === 0 ? 'pass' : 'fail') + '">' +
    passed + '/' + total + ' passed' +
    (failed > 0 ? ', ' + failed + ' failed' : ' \u2014 all green!') + '</span>';
})();
</script>
</body>
</html>
